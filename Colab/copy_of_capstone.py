# -*- coding: utf-8 -*-
"""Copy of Capstone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15gH3p4t1rvja_PYGjNto8dCl_G8NPEsm

# TACO Inspection Demo

This notebook contains several independent scripts that show how to load and visualize the dataset stats and annotated images:
- Section 1 shows the dataset stats
- Section 2 show the class hierarchical structure: super classes and classes
- Section 3 shows TACO images along with their segmentation masks

But first we need to load the annotations and some python libraries:

# **Importing Dataset From Drive**
"""

from google.colab import drive
drive.mount('/content/gdrive')

!cd '/content/gdrive/My Drive/ZAKA/' # MLC 2022/Capstone_Project'
!ls

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !unzip -u "/content/gdrive/MyDrive/ZAKA/TACO.zip" -d "/content" > /dev/null

!unzip -u "/content/gdrive/MyDrive/ZAKA/splits.zip" -d "/" > /dev/null

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns; sns.set()

dataset_path = './TACO/data'
anns_file_path = dataset_path + '/' + 'annotations.json'

# Read annotations
with open(anns_file_path, 'r') as f:
    dataset = json.loads(f.read())

categories = dataset['categories']
anns = dataset['annotations']
imgs = dataset['images']

"""# EDA

Display Num of Files (Categories, Supercategories, num of images and annotations) using JSON file
"""

nr_cats = len(categories)
nr_annotations = len(anns)
nr_images = len(imgs)

# Load categories and super categories
cat_names = []
super_cat_names = []
super_cat_ids = {}
super_cat_last_name = ''
nr_super_cats = 0
for cat_it in categories:
    cat_names.append(cat_it['name'])
    super_cat_name = cat_it['supercategory']
    # Adding new supercat
    if super_cat_name != super_cat_last_name:
        super_cat_names.append(super_cat_name)
        super_cat_ids[super_cat_name] = nr_super_cats
        super_cat_last_name = super_cat_name
        nr_super_cats += 1

print('Number of super categories:', nr_super_cats)
print('Number of categories:', nr_cats)
print('Number of annotations:', nr_annotations)
print('Number of images:', nr_images)

"""Dataset Sections"""

for d in dataset:
  print(d)

"""## 1.  Dataset statistics

This shows the number of annotations per category:
[Annotations are gotten from the dataset["annotations"] from the JSON file]
"""

# Count annotations
cat_histogram = np.zeros(nr_cats,dtype=int)
for ann in anns:
    cat_histogram[ann['category_id']] += 1

# Initialize the matplotlib figure
f, ax = plt.subplots(figsize=(5,15))

# Convert to DataFrame
df = pd.DataFrame({'Categories': cat_names, 'Number of annotations': cat_histogram})
df = df.sort_values('Number of annotations', 0, False)

# Plot the histogram
# sns.set_color_codes("pastel")
# sns.set(style="whitegrid")
plot_1 = sns.barplot(x="Number of annotations", y="Categories", data=df,
            label="Total", color="g")

# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'g', fontweight = 'bold')
# fig = plot_1.get_figure()
# fig.savefig("output.png")

"""and this shows the number of annotations per super category:"""

cat_ids_2_supercat_ids = {}
for cat in categories:
    cat_ids_2_supercat_ids[cat['id']] = super_cat_ids[cat['supercategory']]

# Count annotations
super_cat_histogram = np.zeros(nr_super_cats,dtype=int)
for ann in anns:
    cat_id = ann['category_id']
    super_cat_histogram[cat_ids_2_supercat_ids[cat_id]] +=1

# Initialize the matplotlib figure
f, ax = plt.subplots(figsize=(5,10))
# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'g', fontweight = 'bold')
# Convert to DataFrame
d ={'Super categories': super_cat_names, 'Number of annotations': super_cat_histogram}
df = pd.DataFrame(d)
df = df.sort_values('Number of annotations', 0, False)

# sns.set_color_codes("pastel")
# sns.set(style="whitegrid")

plot_1 = sns.barplot(x="Number of annotations", y="Super categories", data=df,
            label="Total", color="r")
# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'r', fontweight = 'bold')

#plot_1.set_title('Annotations per super category',fontsize=20)

"""### 1.1  Background stats"""

from numpy.lib.function_base import percentile
# Get scene cat names
scene_cats = dataset['scene_categories']
scene_name = []
for scene_cat in scene_cats:
    scene_name.append(scene_cat['name'])

nr_scenes = len(scene_cats)
scene_cat_histogram = np.zeros(nr_scenes,dtype=int)

for scene_ann in dataset['scene_annotations']:
    scene_ann_ids = scene_ann['background_ids']
    for scene_ann_id in scene_ann_ids:
        if scene_ann_id<len(scene_cats):
            scene_cat_histogram[scene_ann_id]+=1

# Convert to DataFrame
df = pd.DataFrame({'scene_cats': scene_cats, 'nr_annotations': scene_cat_histogram})

# Plot
colors = ['gold','yellow','gray', 'lightblue', 'red','lightgreen','orange']
plt.pie(scene_cat_histogram, labels= scene_name, colors = colors,
      shadow=False, startangle=-120, autopct='%1.1f%%', radius=5000)


plt.legend(
    loc='upper right',
    labels=['%s, %1.1f%%' % (
        l, (float(s) / sum(y)) * 100) for l, s in zip(scene_name, scene_cat_histogram)],
    prop={'size': 11},
    bbox_to_anchor=(0.0, 1),
)
plt.axis('equal')
plt.show()

"""## 2. Visualize dataset graph [NEED UPDATE]"""

from graphviz import Digraph
# Note: graphviz may require more than pip installation due to path issue: e.g. brew install graphviz for mac

#g = Digraph('G', filename='hello.gv')
dot = Digraph('Dataset graph', filename='asd.gv')
dot.attr(rankdir='LR', size='8,10')

for cat_it in categories:
    dot.node(cat_it['name'])
    if cat_it['name']==cat_it['supercategory']:
        dot.node(cat_it['supercategory'])
    else:
        dot.edge(cat_it['supercategory'], cat_it['name'])
dot
# Uncomment next line to print pdf
#dot.view()

"""## 3. Visualize Annotated Images

For simplicity, to select and show the dataset images with the respective masks, we make use of the COCO API.
The script below shows how to load and visualize an image with all its annotations.

Unfortunately, several python libraries do not take into account the EXIF orientation tag, thus we have to explicitly rotate the images. Alternatively you can use instead OpenCV.
"""

from PIL import Image, ExifTags, ImageOps
from pycocotools.coco import COCO
from matplotlib.patches import Polygon, Rectangle
from matplotlib.collections import PatchCollection
import colorsys
import random
import pylab

# User settings
image_filepath = 'batch_2/000005.JPG'
pylab.rcParams['figure.figsize'] = (5,5)
####################

# Obtain Exif orientation tag code
for orientation in ExifTags.TAGS.keys():
    if ExifTags.TAGS[orientation] == 'Orientation':
        break

# Loads dataset as a coco object
coco = COCO(anns_file_path)

# Find id of the image selected previously (image_filepath)
img_id = -1
for img in imgs:
    if img['file_name'] == image_filepath:
        img_id = img['id']
        path = img['flickr_640_url']
        print(path)
        break

# Show image and corresponding annotations
if img_id == -1:
    print('Incorrect file name')
else:

    # Load image
    print(image_filepath)
    I = Image.open(dataset_path + '/' + image_filepath)
    # Automatically perform the EXIF orientation if available
    # I = ImageOps.exif_transpose(I)
    # newsize = (942, 1074)
    # I = I.resize(newsize)

    # # Load and process image metadata
    if I._getexif():
        exif = dict(I._getexif().items())
        print(exif)
        # Rotate portrait and upside down images if necessary
        if orientation in exif:
            if exif[orientation] == 3:
                I = I.rotate(180,expand=True)
            if exif[orientation] == 6:
                I = I.rotate(270,expand=True)
            if exif[orientation] == 8:
                I = I.rotate(90,expand=True)

    # Show image
    fig,ax = plt.subplots(1)
    plt.axis('off')
    plt.imshow(I)

    # Load mask ids
    ## load annotations of an image using its ID
    annIds = coco.getAnnIds(imgIds=img_id, catIds=[], iscrowd=None)
    anns_sel = coco.loadAnns(annIds)

    # Show annotations
    for ann in anns_sel:
        color = colorsys.hsv_to_rgb(np.random.random(),1,1)
        for seg in ann['segmentation']:
            poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
            # Area drawing
            p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
            ax.add_collection(p)
            # Boundary drawing
            p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
            ax.add_collection(p)
        [x, y, w, h] = ann['bbox']
        rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
                         facecolor='none', alpha=0.7, linestyle = '--')
        ax.add_patch(rect)

    plt.show()

"""The script below shows how to filter images by either category or supercategory.

Go ahead and try different (super)categories searches by changing the `category_name`.
Note that small objects may be hard to see.
"""

from PIL import Image, ExifTags
from pycocotools.coco import COCO
from matplotlib.patches import Polygon, Rectangle
from matplotlib.collections import PatchCollection
import colorsys
import random
import pylab

# User settings
nr_img_2_display = 10
category_name = 'Bottle'#  --- Insert the name of one of the categories or super-categories above
pylab.rcParams['figure.figsize'] = (14,14)
####################

# Obtain Exif orientation tag code
for orientation in ExifTags.TAGS.keys():
    if ExifTags.TAGS[orientation] == 'Orientation':
        break

# Loads dataset as a coco object
coco = COCO(anns_file_path)

# Get image ids
imgIds = []
catIds = coco.getCatIds(catNms=[category_name])
if catIds:
    # Get all images containing an instance of the chosen category
    imgIds = coco.getImgIds(catIds=catIds)
else:
    # Get all images containing an instance of the chosen super category
    catIds = coco.getCatIds(supNms=[category_name])
    for catId in catIds:
        imgIds += (coco.getImgIds(catIds=catId))
    imgIds = list(set(imgIds))

nr_images_found = len(imgIds)
print('Number of images found: ',nr_images_found)

# Select N random images
random.shuffle(imgIds)
imgs = coco.loadImgs(imgIds[0:min(nr_img_2_display,nr_images_found)])

for img in imgs:
    image_path = dataset_path + '/' + img['file_name']
    # Load image
    I = Image.open(image_path)
    # I = ImageOps.exif_transpose(I)

    # Load and process image metadata
    if I._getexif():
        exif = dict(I._getexif().items())
        # Rotate portrait and upside down images if necessary
        if orientation in exif:
            if exif[orientation] == 3:
                I = I.rotate(180,expand=True)
            if exif[orientation] == 6:
                I = I.rotate(270,expand=True)
            if exif[orientation] == 8:
                I = I.rotate(90,expand=True)

    # Show image
    fig,ax = plt.subplots(1)
    plt.axis('off')
    plt.imshow(I)

    # Load mask ids
    annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
    anns_sel = coco.loadAnns(annIds)

    # Show annotations
    for ann in anns_sel:
        color = colorsys.hsv_to_rgb(np.random.random(),1,1)
        for seg in ann['segmentation']:
            poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
            p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
            ax.add_collection(p)
            p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
            ax.add_collection(p)
        [x, y, w, h] = ann['bbox']
        rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
                         facecolor='none', alpha=0.7, linestyle = '--')
        ax.add_patch(rect)

    plt.show()

"""# Num of photos in each batch (Not important)"""

import os
# num of photos in each batch
!ls 'TACO/data'
directory = '/content/TACO/data/'
files = os.listdir(directory)
print(files)
tot = 0
for file in files:
  if file[0] == 'b':
    f = os.listdir(directory + file)
    # print(f)
    file_count = len(set(f))
    tot += file_count - 1
    print(file + ': ' + str(file_count))
print(tot)

"""# Images Size
Get avg image height and width and scale them down to reduce the training size.
## We can add the size plot
"""

images = dataset2["images"]
tot_width = 0
tot_height = 0
tot = 0
for image in images:
  tot_width += image["width"]
  tot_height += image["height"]
  tot += 1
avg_width = tot_width/tot
avg_height = tot_height/tot
print('Total: {}, Total Width: {}, and Total Height: {}'.format(tot, tot_width, tot_height))
print('Avg Width: {}, and Avg Height: {}'.format(round(avg_width), round(avg_height)))
print('Scaled Width: {}, and Scaled Height: {}'.format(round(avg_width/3), round(avg_height/3)))

new_dataset_path = './new_dataset2.json'
# Read annotations
with open(new_dataset_path, 'r') as f:
    dataset2 = json.loads(f.read())

imgs = dataset2['images']

"""# CLASSES GROUPING [1]: 7 Categories

Duplicates
"""

anns = dataset['annotations']
ids = []
for ann in anns:
  if ann['id'] == 4040:
    print(ann)
  if ann['id'] in ids:
    print(ann)
  ids.append(ann['id'])
a = list(range(1, 4783))
print(len(a) == len(set(ids)))

import copy
anns = copy.deepcopy(dataset['annotations'])
ids = []
last  = anns[-1]['id']
for ann in anns:
  if ann['id'] in ids:
    last += 1
    ann['id'] = last
    # anns.append(ann)
    print(ann)
    ids.append(ann['id'])
  else:
    ids.append(ann['id'])

for ann in anns:
  if dataset['annotations'] == 4785:
    print(True)

for ann in anns:
  if ann['id'] == 4785:
    print(True)

# This function converts the different categories into 7 categories based on their material
def taco_to_recycle(label):
    glass = ['Glass bottle','Broken glass','Glass jar']
    metals_and_plastics = ['Aluminium foil', "Clear plastic bottle","Other plastic bottle",
                         "Plastic bottle cap","Metal bottle cap","Aerosol","Drink can",
                         "Food can","Drink carton","Disposable plastic cup","Other plastic cup",
                         "Plastic lid","Metal lid","Single-use carrier bag","Polypropylene bag",
                         "Plastic Film","Six pack rings","Spread tub","Tupperware",
                         "Disposable food container","Other plastic container",
                         "Plastic glooves","Plastic utensils","Pop tab","Scrap metal",
                         "Plastic straw","Other plastic", "Plastic film", "Food Can"]

    non_recyclable = ["Aluminium blister pack","Carded blister pack",
                    "Meal carton","Pizza box","Cigarette","Paper cup",
                    "Meal carton","Foam cup","Glass cup","Wrapping paper",
                    "Magazine paper","Garbage bag","Plastified paper bag",
                    "Crisp packet","Other plastic wrapper","Foam food container",
                    "Rope","Shoe","Squeezable tube","Paper straw","Styrofoam piece", "Rope & strings", "Tissues"]

    other = ["Battery"]
    paper = ["Corrugated carton","Egg carton","Toilet tube","Other carton", "Normal paper", "Paper bag"]
    bio = ["Food waste"]
    unknown = ["Unlabeled litter"]

    if (label in glass):
            label="glass"
    elif (label in metals_and_plastics):
            label="metals_and_plastics"
    elif(label in non_recyclable):
            label="non-recyclable"
    elif(label in other):
            label="other"
    elif (label in paper):
            label="paper"
    elif(label in bio):
            label="bio"
    elif(label in unknown):
            label="unknown"
    else:
        print(label, "is non-taco label")
        label = "unknown"
    return label

"""Converting annotaion 'category_id' to the new categories"""

new_categories = copy.deepcopy(dataset['categories'])
for ann in anns:
    cat_id = ann['category_id']
    cat_taco = dataset['categories'][cat_id]['name']
    new_categories[cat_id]['supercategory'] = taco_to_recycle(cat_taco)
# As there is no representation of "Plastified paper bag" in annotated data, change of this supercategory was done manually.
new_categories[35]['supercategory'] = taco_to_recycle("Plastified paper bag")

"""Create new categories dictionary


"""

new_categories_ids = {}
new_categories_names = []
cat_id = 0
for cat in new_categories:
    if cat['supercategory'] not in new_categories_ids:
        new_categories_names.append(cat['supercategory'])
        new_categories_ids[cat['supercategory']] = cat_id
        cat_id += 1

print(new_categories_ids)
print(new_categories_names)

"""change categories to new format"""

new_cat_json = dataset['categories'][0:7]
for num in new_categories_ids.values():
  new_cat_json[num]['supercategory'] = list(new_categories_ids.keys())[num]
  new_cat_json[num]['id'] = num
  new_cat_json[num]['name'] = ''
new_cat_json

"""Change category_ids from the annotations"""

taco_to_new_categories_ids = {} # mapping dictionary
for i, cat in enumerate(new_categories): # replace the ids in new_categories
#     if cat['id'] not in taco_to_new_categories_ids:
#         taco_to_new_categories_ids[cat['id']] = 0
    taco_to_new_categories_ids[cat['id']] = new_categories_ids[cat['supercategory']]

# print(taco_to_detectwaste_ids)
anns_new = anns.copy()
for i, ann in enumerate(anns):
    #print(ann['category_id'])
    anns_new[i]['category_id'] = taco_to_new_categories_ids[ann['category_id']]
    # anns_new[i].pop('segmentation', None)

"""Check the number of annotations per new category"""

categories = new_categories

# Load categories and super categories
super_cat_names = []
super_cat_ids = {}
super_cat_used_name = []
nr_super_cats = 0
for cat_it in categories:
    super_cat_name = cat_it['supercategory']
    # Adding new supercat
    if super_cat_name not in super_cat_used_name:
        super_cat_names.append(super_cat_name)
        super_cat_ids[super_cat_name] = nr_super_cats
        super_cat_used_name.append(super_cat_name)
        nr_super_cats += 1

print('Number of categories:', nr_super_cats)

cat_ids_2_supercat_ids = {}
for cat in new_categories:
    cat_ids_2_supercat_ids[cat['id']] = super_cat_ids[cat['supercategory']]

# Count annotations
super_cat_histogram = np.zeros(7,dtype=int)

for ann in anns_new:
    cat_id = ann['category_id']
    super_cat_histogram[cat_id] +=1

# Initialize the matplotlib figure
f, ax = plt.subplots(figsize=(5,10))

# Convert to DataFrame
d ={'New categories': new_categories_names, 'Number of annotations': super_cat_histogram}
df = pd.DataFrame(d)
df = df.sort_values('Number of annotations', 0, False)

# sns.set_color_codes("pastel")
# sns.set(style="whitegrid")

plot_1 = sns.barplot(x="Number of annotations", y="New categories", data=df,
            label="Total", color="r")

# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'r', fontweight = 'bold')

#plot_1.set_title('Annotations per super category',fontsize=20)

"""For the new JSON file after changing categories we need to change 'annotations' and 'categories' with the new ones"""

dataset.keys()

# Add the unchanged categories
new_dataset = {
    'info': None,
    'images': [],
    'annotations': [],
    'scene_annotations': [],
    'licenses': [],
    'categories': [],
    'scene_categories': [],
}

new_dataset['info'] =  dataset['info']
new_dataset['images'] =  dataset['images']
new_dataset['annotations'] = anns_new
new_dataset['scene_annotations'] = dataset['scene_annotations']
new_dataset['licenses'] = dataset['licenses']
new_dataset['categories'] = new_cat_json #new_categories
new_dataset['scene_categories'] = dataset['scene_categories']

!pwd

new_dataset_out_path = './new_dataset2.json'

with open(new_dataset_out_path, 'w+') as f:
    f.write(json.dumps(new_dataset))

"""Testing the new JSON File"""

# from PIL import Image, ExifTags, ImageOps
# from pycocotools.coco import COCO
# from matplotlib.patches import Polygon, Rectangle
# from matplotlib.collections import PatchCollection
# import colorsys
# import random
# import pylab

# def show_img(anns_file_path, image_path = 'batch_11/000028.jpg'):
#   # User settings
#   image_filepath = image_path
#   pylab.rcParams['figure.figsize'] = (5,5)
#   ####################

#   # Obtain Exif orientation tag code
#   for orientation in ExifTags.TAGS.keys():
#       if ExifTags.TAGS[orientation] == 'Orientation':
#           break

#   # Loads dataset as a coco object
#   coco = COCO(anns_file_path)

#   # Find id of the image selected previously (image_filepath)
#   img_id = -1
#   for img in imgs:
#       if img['file_name'] == image_filepath:
#           img_id = img['id']
#           path = img['flickr_640_url']
#           print(path)
#           break

#   # Show image and corresponding annotations
#   if img_id == -1:
#       print('Incorrect file name')
#   else:

#       # Load image
#       print(image_filepath)
#       I = Image.open(dataset_path + '/' + image_filepath)
#       # Automatically perform the EXIF orientation if available
#       I = ImageOps.exif_transpose(I)

#       # Show image
#       fig,ax = plt.subplots(1)
#       plt.axis('off')
#       plt.imshow(I)

#       # Load mask ids
#       ## load annotations of an image using its ID
#       annIds = coco.getAnnIds(imgIds=img_id, catIds=[], iscrowd=None)
#       anns_sel = coco.loadAnns(annIds)

#       # Show annotations
#       for ann in anns_sel:
#           color = colorsys.hsv_to_rgb(np.random.random(),1,1)
#           for seg in ann['segmentation']:
#               poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
#               # Area drawing
#               p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
#               ax.add_collection(p)
#               # Boundary drawing
#               p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
#               ax.add_collection(p)
#           [x, y, w, h] = ann['bbox']
#           rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
#                           facecolor='none', alpha=0.7, linestyle = '--')
#           ax.add_patch(rect)

#       plt.show()

def show_img_class(json_path, category_name = 'bio', nr_img_2_display = 5):
  # User settings
  pylab.rcParams['figure.figsize'] = (5,5)
  ####################

  # Obtain Exif orientation tag code
  for orientation in ExifTags.TAGS.keys():
      if ExifTags.TAGS[orientation] == 'Orientation':
          break

  # Loads dataset as a coco object
  coco = COCO(json_path)

  # Get image ids
  imgIds = []
  catIds = coco.getCatIds(catNms=[category_name])

  if catIds:
      # Get all images containing an instance of the chosen category
      imgIds = coco.getImgIds(catIds=catIds)
  else:
      # Get all images containing an instance of the chosen super category
      catIds = coco.getCatIds(supNms=[category_name])
      for catId in catIds:
          imgIds += (coco.getImgIds(catIds=catId))
      imgIds = list(set(imgIds))
  print(catIds)
  nr_images_found = len(imgIds)
  print('Number of images found: ',nr_images_found)

  # Select N random images
  random.shuffle(imgIds)
  imgs = coco.loadImgs(imgIds[0:min(nr_img_2_display,nr_images_found)])

  for img in imgs:
      image_path = dataset_path + '/' + img['file_name']
      # Load image
      I = Image.open(image_path)
      # I = ImageOps.exif_transpose(I)

      # Load and process image metadata
      if I._getexif():
          exif = dict(I._getexif().items())
          # Rotate portrait and upside down images if necessary
          if orientation in exif:
              if exif[orientation] == 3:
                  I = I.rotate(180,expand=True)
              if exif[orientation] == 6:
                  I = I.rotate(270,expand=True)
              if exif[orientation] == 8:
                  I = I.rotate(90,expand=True)

      # Show image
      fig,ax = plt.subplots(1)
      plt.axis('off')
      plt.imshow(I)

      # Load mask ids
      annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
      anns_sel = coco.loadAnns(annIds)

      # Show annotations
      for ann in anns_sel:
          color = colorsys.hsv_to_rgb(np.random.random(),1,1)
          for seg in ann['segmentation']:
              poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
              p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
              ax.add_collection(p)
              p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
              ax.add_collection(p)
          [x, y, w, h] = ann['bbox']
          rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
                          facecolor='none', alpha=0.7, linestyle = '--')
          ax.add_patch(rect)

      plt.show()

"""# CLASSES GROUPING [2]: 7 Cats (Updated)
7 cats: the first 6 and 'others' cat
"""

anns = dataset['annotations']
ids = []
for ann in anns:
  if ann['id'] == 4040:
    print(ann)
  if ann['id'] in ids:
    print(ann)
  ids.append(ann['id'])
a = list(range(1, 4783))
print(len(ids) == len(set(ids)))

import copy
anns = copy.deepcopy(dataset['annotations'])
ids = []
last  = anns[-1]['id']
for ann in anns:
  if ann['id'] in ids:
    last += 1
    ann['id'] = last
    # anns.append(ann)
    print(ann)
    ids.append(ann['id'])
  else:
    ids.append(ann['id'])

for ann in anns:
  if dataset['annotations'] == 4785:
    print(True)

for ann in anns:
  if ann['id'] == 4785:
    print(True)

# This function converts the different categories into 7 categories based on their material
def taco_to_recycle(label):

    Cigarette = ['Cigarette']

    Plastic_bag_and_wrapper = ['Plastic bag & wrapper']
    Bottle_Cap = ["Bottle cap"]
    Bottle = ["Bottle"]
    Can = ["Can"]

    Unlabeled_litter = ["Unlabeled litter"]

    if (label in Cigarette):
            label="Cigarette"
    elif (label in Plastic_bag_and_wrapper):
            label="Plastic bag & wrapper"
    elif(label in Bottle_Cap):
            label="Bottle cap"
    elif(label in Bottle):
            label="Bottle"
    elif (label in Can):
            label="Can"
    elif(label in Unlabeled_litter):
            label="Unlabeled litter"
    else:
        print(label, "is non-taco label")
        label = "Other"
    return label

"""Converting annotaion 'category_id' to the new categories"""

new_categories = copy.deepcopy(dataset['categories'])
for ann in anns:
    cat_id = ann['category_id']
    cat_taco = dataset['categories'][cat_id]['supercategory']
    new_categories[cat_id]['supercategory'] = taco_to_recycle(cat_taco)
# As there is no representation of "Plastified paper bag" in annotated data, change of this supercategory was done manually.
new_categories[35]['supercategory'] = taco_to_recycle("Plastified paper bag")

"""Create new categories dictionary


"""

new_categories_ids = {}
new_categories_names = []
cat_id = 0
for cat in new_categories:
    if cat['supercategory'] not in new_categories_ids:
        new_categories_names.append(cat['supercategory'])
        new_categories_ids[cat['supercategory']] = cat_id
        cat_id += 1

print(new_categories_ids)
print(new_categories_names)

"""change categories to new format"""

new_cat_json = dataset['categories'][0:7]
for num in new_categories_ids.values():
  new_cat_json[num]['supercategory'] = list(new_categories_ids.keys())[num]
  new_cat_json[num]['id'] = num
  new_cat_json[num]['name'] = ''
new_cat_json

"""Change category_ids from the annotations"""

taco_to_new_categories_ids = {} # mapping dictionary
for i, cat in enumerate(new_categories): # replace the ids in new_categories
#     if cat['id'] not in taco_to_new_categories_ids:
#         taco_to_new_categories_ids[cat['id']] = 0
    taco_to_new_categories_ids[cat['id']] = new_categories_ids[cat['supercategory']]

# print(taco_to_detectwaste_ids)
anns_new = anns.copy()
for i, ann in enumerate(anns):
    #print(ann['category_id'])
    anns_new[i]['category_id'] = taco_to_new_categories_ids[ann['category_id']]
    # anns_new[i].pop('segmentation', None)

"""Check the number of annotations per new category"""

categories = new_categories

# Load categories and super categories
super_cat_names = []
super_cat_ids = {}
super_cat_used_name = []
nr_super_cats = 0
for cat_it in categories:
    super_cat_name = cat_it['supercategory']
    # Adding new supercat
    if super_cat_name not in super_cat_used_name:
        super_cat_names.append(super_cat_name)
        super_cat_ids[super_cat_name] = nr_super_cats
        super_cat_used_name.append(super_cat_name)
        nr_super_cats += 1

print('Number of categories:', nr_super_cats)

cat_ids_2_supercat_ids = {}
for cat in new_categories:
    cat_ids_2_supercat_ids[cat['id']] = super_cat_ids[cat['supercategory']]

# Count annotations
super_cat_histogram = np.zeros(7,dtype=int)

for ann in anns_new:
    cat_id = ann['category_id']
    super_cat_histogram[cat_id] +=1

# Initialize the matplotlib figure
f, ax = plt.subplots(figsize=(5,10))

# Convert to DataFrame
d ={'New categories': new_categories_names, 'Number of annotations': super_cat_histogram}
df = pd.DataFrame(d)
df = df.sort_values('Number of annotations', 0, False)

# sns.set_color_codes("pastel")
# sns.set(style="whitegrid")

plot_1 = sns.barplot(x="Number of annotations", y="New categories", data=df,
            label="Total", color="r")

# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'r', fontweight = 'bold')

#plot_1.set_title('Annotations per super category',fontsize=20)

"""For the new JSON file after changing categories we need to change 'annotations' and 'categories' with the new ones"""

dataset.keys()

# Add the unchanged categories
new_dataset = {
    'info': None,
    'images': [],
    'annotations': [],
    'scene_annotations': [],
    'licenses': [],
    'categories': [],
    'scene_categories': [],
}

new_dataset['info'] =  dataset['info']
new_dataset['images'] =  dataset['images']
new_dataset['annotations'] = anns_new
new_dataset['scene_annotations'] = dataset['scene_annotations']
new_dataset['licenses'] = dataset['licenses']
new_dataset['categories'] = new_cat_json #new_categories
new_dataset['scene_categories'] = dataset['scene_categories']

!pwd

new_dataset_out_path = './new_dataset_cats.json'

with open(new_dataset_out_path, 'w+') as f:
    f.write(json.dumps(new_dataset))

"""Testing the new JSON File"""

from PIL import Image, ExifTags, ImageOps
from pycocotools.coco import COCO
from matplotlib.patches import Polygon, Rectangle
from matplotlib.collections import PatchCollection
import colorsys
import random
import pylab

def show_img(anns_file_path, image_path = 'batch_11/000028.jpg'):
  # User settings
  image_filepath = image_path
  pylab.rcParams['figure.figsize'] = (5,5)
  ####################

  # Obtain Exif orientation tag code
  for orientation in ExifTags.TAGS.keys():
      if ExifTags.TAGS[orientation] == 'Orientation':
          break

  # Loads dataset as a coco object
  coco = COCO(anns_file_path)

  # Find id of the image selected previously (image_filepath)
  img_id = -1
  for img in imgs:
      if img['file_name'] == image_filepath:
          img_id = img['id']
          path = img['flickr_640_url']
          print(path)
          break

  # Show image and corresponding annotations
  if img_id == -1:
      print('Incorrect file name')
  else:

      # Load image
      print(image_filepath)
      I = Image.open(dataset_path + '/' + image_filepath)
      # Automatically perform the EXIF orientation if available
      I = ImageOps.exif_transpose(I)

      # Show image
      fig,ax = plt.subplots(1)
      plt.axis('off')
      plt.imshow(I)

      # Load mask ids
      ## load annotations of an image using its ID
      annIds = coco.getAnnIds(imgIds=img_id, catIds=[], iscrowd=None)
      anns_sel = coco.loadAnns(annIds)

      # Show annotations
      for ann in anns_sel:
          color = colorsys.hsv_to_rgb(np.random.random(),1,1)
          for seg in ann['segmentation']:
              poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
              # Area drawing
              p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
              ax.add_collection(p)
              # Boundary drawing
              p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
              ax.add_collection(p)
          [x, y, w, h] = ann['bbox']
          rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
                          facecolor='none', alpha=0.7, linestyle = '--')
          ax.add_patch(rect)

      plt.show()

show_img('/content/new_dataset_cats.json')

def show_img_class(json_path, category_name = 'bio', nr_img_2_display = 5):
  # User settings
  pylab.rcParams['figure.figsize'] = (5,5)
  ####################

  # Obtain Exif orientation tag code
  for orientation in ExifTags.TAGS.keys():
      if ExifTags.TAGS[orientation] == 'Orientation':
          break

  # Loads dataset as a coco object
  coco = COCO(json_path)

  # Get image ids
  imgIds = []
  catIds = coco.getCatIds(catNms=[category_name])

  if catIds:
      # Get all images containing an instance of the chosen category
      imgIds = coco.getImgIds(catIds=catIds)
  else:
      # Get all images containing an instance of the chosen super category
      catIds = coco.getCatIds(supNms=[category_name])
      for catId in catIds:
          imgIds += (coco.getImgIds(catIds=catId))
      imgIds = list(set(imgIds))
  print(catIds)
  nr_images_found = len(imgIds)
  print('Number of images found: ',nr_images_found)

  # Select N random images
  random.shuffle(imgIds)
  imgs = coco.loadImgs(imgIds[0:min(nr_img_2_display,nr_images_found)])

  for img in imgs:
      image_path = dataset_path + '/' + img['file_name']
      # Load image
      I = Image.open(image_path)
      # I = ImageOps.exif_transpose(I)

      # Load and process image metadata
      if I._getexif():
          exif = dict(I._getexif().items())
          # Rotate portrait and upside down images if necessary
          if orientation in exif:
              if exif[orientation] == 3:
                  I = I.rotate(180,expand=True)
              if exif[orientation] == 6:
                  I = I.rotate(270,expand=True)
              if exif[orientation] == 8:
                  I = I.rotate(90,expand=True)

      # Show image
      fig,ax = plt.subplots(1)
      plt.axis('off')
      plt.imshow(I)

      # Load mask ids
      annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
      anns_sel = coco.loadAnns(annIds)

      # Show annotations
      for ann in anns_sel:
          color = colorsys.hsv_to_rgb(np.random.random(),1,1)
          for seg in ann['segmentation']:
              poly = Polygon(np.array(seg).reshape((int(len(seg)/2), 2)))
              p = PatchCollection([poly], facecolor=color, edgecolors=color,linewidths=0, alpha=0.4)
              ax.add_collection(p)
              p = PatchCollection([poly], facecolor='none', edgecolors=color, linewidths=2)
              ax.add_collection(p)
          [x, y, w, h] = ann['bbox']
          rect = Rectangle((x,y),w,h,linewidth=2,edgecolor=color,
                          facecolor='none', alpha=0.7, linestyle = '--')
          ax.add_patch(rect)

      plt.show()



"""# CLASSES SPLITTING [3]:
All to 1 category 'litter'
"""

anns = dataset['annotations']
ids = []
for ann in anns:
  if ann['id'] == 4040:
    print(ann)
  if ann['id'] in ids:
    print(ann)
  ids.append(ann['id'])
a = list(range(1, 4783))
print(len(ids) == len(set(ids)))

import copy
anns = copy.deepcopy(dataset['annotations'])
ids = []
last  = anns[-1]['id']
for ann in anns:
  if ann['id'] in ids:
    last += 1
    ann['id'] = last
    # anns.append(ann)
    print(ann)
    ids.append(ann['id'])
  else:
    ids.append(ann['id'])

for ann in anns:
  if dataset['annotations'] == 4785:
    print(True)

for ann in anns:
  if ann['id'] == 4785:
    print(True)

"""Converting annotaion 'category_id' to the new categories"""

new_categories = copy.deepcopy(dataset['categories'])
for ann in anns:
    cat_id = ann['category_id']
    cat_taco = dataset['categories'][cat_id]['supercategory']
    new_categories[cat_id]['supercategory'] = 'litter'
# As there is no representation of "Plastified paper bag" in annotated data, change of this supercategory was done manually.
new_categories[35]['supercategory'] = 'litter'

"""Create new categories dictionary


"""

new_categories_ids = {}
new_categories_names = []
cat_id = 0
for cat in new_categories:
    if cat['supercategory'] not in new_categories_ids:
        new_categories_names.append(cat['supercategory'])
        new_categories_ids[cat['supercategory']] = cat_id
        cat_id += 1

print(new_categories_ids)
print(new_categories_names)

"""change categories to new format"""

new_cat_json = dataset['categories'][0:1]
for num in new_categories_ids.values():
  new_cat_json[num]['supercategory'] = list(new_categories_ids.keys())[num]
  new_cat_json[num]['id'] = num
  new_cat_json[num]['name'] = ''
new_cat_json

"""Change category_ids from the annotations"""

taco_to_new_categories_ids = {} # mapping dictionary
for i, cat in enumerate(new_categories): # replace the ids in new_categories
#     if cat['id'] not in taco_to_new_categories_ids:
#         taco_to_new_categories_ids[cat['id']] = 0
    taco_to_new_categories_ids[cat['id']] = new_categories_ids[cat['supercategory']]

# print(taco_to_detectwaste_ids)
anns_new = anns.copy()
for i, ann in enumerate(anns):
    #print(ann['category_id'])
    anns_new[i]['category_id'] = taco_to_new_categories_ids[ann['category_id']]
    # anns_new[i].pop('segmentation', None)

"""Check the number of annotations per new category"""

categories = new_categories

# Load categories and super categories
super_cat_names = []
super_cat_ids = {}
super_cat_used_name = []
nr_super_cats = 0
for cat_it in categories:
    super_cat_name = cat_it['supercategory']
    # Adding new supercat
    if super_cat_name not in super_cat_used_name:
        super_cat_names.append(super_cat_name)
        super_cat_ids[super_cat_name] = nr_super_cats
        super_cat_used_name.append(super_cat_name)
        nr_super_cats += 1

print('Number of categories:', nr_super_cats)

cat_ids_2_supercat_ids = {}
for cat in new_categories:
    cat_ids_2_supercat_ids[cat['id']] = super_cat_ids[cat['supercategory']]

# Count annotations
super_cat_histogram = np.zeros(1,dtype=int)

for ann in anns_new:
    cat_id = ann['category_id']
    super_cat_histogram[cat_id] +=1

# Initialize the matplotlib figure
f, ax = plt.subplots(figsize=(2,1))

# Convert to DataFrame
d ={'New categories': new_categories_names, 'Number of annotations': super_cat_histogram}
df = pd.DataFrame(d)
df = df.sort_values('Number of annotations', 0, False)

# sns.set_color_codes("pastel")
# sns.set(style="whitegrid")

plot_1 = sns.barplot(x="Number of annotations", y="New categories", data=df,
            label="Total", color="r")

# get the number of img in each cat
y=[]
for p in plot_1.patches:
    y.append(p.get_width())
# Plotting the numbers of img in each cat
for i, v in enumerate(y):
  plot_1.text(v + 3, i + .25, str(v), color = 'r', fontweight = 'bold')

#plot_1.set_title('Annotations per super category',fontsize=20)

"""For the new JSON file after changing categories we need to change 'annotations' and 'categories' with the new ones"""

dataset.keys()

# Add the unchanged categories
new_dataset = {
    'info': None,
    'images': [],
    'annotations': [],
    'scene_annotations': [],
    'licenses': [],
    'categories': [],
    'scene_categories': [],
}

new_dataset['info'] =  dataset['info']
new_dataset['images'] =  dataset['images']
new_dataset['annotations'] = anns_new
new_dataset['scene_annotations'] = dataset['scene_annotations']
new_dataset['licenses'] = dataset['licenses']
new_dataset['categories'] = new_cat_json #new_categories
new_dataset['scene_categories'] = dataset['scene_categories']

!pwd

new_dataset_out_path = './new_dataset_1.json'

with open(new_dataset_out_path, 'w+') as f:
    f.write(json.dumps(new_dataset))

"""# ***Splitting:***

"""

import random
import copy

ann_input_path = './new_dataset_1.json' # 3rd group
# ann_input_path = './new_dataset2.json' # 2rd group
# ann_input_path = './new_dataset_cats.json' # 1rd group

test_percentage = 10
val_percentage = 10
# Num of photos for inference
inference_num = 50

# Load annotations
with open(ann_input_path, 'r') as f:
    dataset = json.loads(f.read())

anns = dataset['annotations']
scene_anns = dataset['scene_annotations']
imgs = dataset['images']
nr_images = len(imgs)

nr_testing_images = int(nr_images*test_percentage*0.01+0.5 - inference_num/2)
nr_nontraining_images = int(nr_images*(test_percentage+val_percentage)*0.01+0.5 - inference_num)

print('Num of images: {}'.format(nr_images))
print('Num of testing images: {}, and num of train+val images: {}'.format(nr_testing_images, nr_nontraining_images))

import copy
random.shuffle(imgs)

train_set = []
val_set = []
inf_set = []
test_val_set = []

# Add new datasets
train_set = {
    'info': None,
    'images': [],
    'annotations': [],
    'scene_annotations': [],
    'licenses': [],
    'categories': [],
    'scene_categories': [],
}

train_set['info'] =  dataset['info']
train_set['categories'] = dataset['categories']
train_set['scene_categories'] = dataset['scene_categories']
train_set['licenses'] = dataset['licenses']
train_set['licenses'] = dataset['licenses']

val_set = copy.deepcopy(train_set)
test_set = copy.deepcopy(train_set)
inf_set = copy.deepcopy(train_set)
test_val_set = copy.deepcopy(train_set)

# Splitting Images
test_set['images'] = imgs[0:nr_testing_images]
val_set['images'] = imgs[nr_testing_images:nr_nontraining_images]
test_val_set['images'] = test_set['images'] + val_set['images']
train_set['images'] = imgs[nr_nontraining_images:nr_images - inference_num]
inf_set['images'] = imgs[nr_images - inference_num:nr_images]

train_set_len = len(train_set['images'])
val_set_len = len(val_set['images'])
test_set_len = len(test_set['images'])
inf_set_len = len(inf_set['images'])
test_val_set_len = len(test_val_set['images'])

print(f'Training images: {train_set_len}, Validation images: {val_set_len}, Testing images: {test_set_len} ,and Inference images: {inf_set_len}, combined: {test_val_set_len}')

# Aux Image Ids to split annotations
test_img_ids, val_img_ids, train_img_ids, inf_img_ids, test_val_ids = [],[],[],[],[]
for img in test_set['images']:
    test_img_ids.append(img['id'])

for img in val_set['images']:
    val_img_ids.append(img['id'])

for img in train_set['images']:
    train_img_ids.append(img['id'])

for img in inf_set['images']:
    inf_img_ids.append(img['id'])

for img in test_val_set['images']:
    test_val_ids.append(img['id'])

# Split instance annotations
for ann in anns:
    if ann['image_id'] in test_img_ids:
        test_set['annotations'].append(ann)
    elif ann['image_id'] in val_img_ids:
        val_set['annotations'].append(ann)
    elif ann['image_id'] in train_img_ids:
        train_set['annotations'].append(ann)
    elif ann['image_id'] in inf_img_ids:
        inf_set['annotations'].append(ann)

test_val_set['annotations'] = val_set['annotations'] +test_set['annotations']


# Split scene tags
for ann in scene_anns:
    if ann['image_id'] in test_img_ids:
        test_set['scene_annotations'].append(ann)
    elif ann['image_id'] in val_img_ids:
        val_set['scene_annotations'].append(ann)
    elif ann['image_id'] in train_img_ids:
        train_set['scene_annotations'].append(ann)
    elif ann['image_id'] in inf_img_ids:
        inf_set['scene_annotations'].append(ann)

test_val_set['scene_annotations'] = val_set['scene_annotations'] +test_set['scene_annotations']

train_set_len = len(train_set['annotations'])
val_set_len = len(val_set['annotations'])
test_set_len = len(test_set['annotations'])
inf_set_len = len(inf_set['annotations'])
test_val_set_len = len(test_val_set['annotations'])

print(f'Training annotations: {train_set_len}, Validation annotations: {val_set_len}, Testing annotations: {test_set_len}, and Inference annotations: {inf_set_len}, combined: {test_val_set_len}')

"""Create JSON File for the new train, test, and val"""

# Write dataset splits
!mkdir SplittedData
dataset_dir = './SplittedData'

ann_train_out_path = dataset_dir + '/' + 'train.json'
ann_val_out_path   = dataset_dir + '/' + 'val.json'
ann_test_out_path  = dataset_dir + '/' + 'test.json'
ann_inf_out_path  = dataset_dir + '/' + 'inf.json'
ann_test_val_out_path  = dataset_dir + '/' + 'test_val.json'

with open(ann_train_out_path, 'w+') as f:
    f.write(json.dumps(train_set))

with open(ann_val_out_path, 'w+') as f:
    f.write(json.dumps(val_set))

with open(ann_test_out_path, 'w+') as f:
    f.write(json.dumps(test_set))

with open(ann_inf_out_path, 'w+') as f:
    f.write(json.dumps(inf_set))

with open(ann_test_val_out_path, 'w+') as f:
    f.write(json.dumps(test_val_set))

"""Testing the new JSON Files

# **Detectron2Model**

Importing
"""

!pip install 'git+https://github.com/facebookresearch/detectron2.git' > /dev/null

"""Preparing CFG File"""

import json
from detectron2.data import MetadataCatalog, DatasetCatalog
from detectron2.data.datasets import register_coco_instances

register_coco_instances('train',{},'/content/SplittedData/train.json', '/content/TACO/data')
register_coco_instances('test',{},'/content/SplittedData/test.json', '/content/TACO/data')
register_coco_instances('val',{},'/content/SplittedData/val.json', '/content/TACO/data')
register_coco_instances('test_val',{},'/content/SplittedData/test_val.json', '/content/TACO/data')

# for d in ["train"]:#, "val", "test"]:
    # DatasetCatalog.register(d, lambda d=d: load_data(d))
    # MetadataCatalog.get(d).set(thing_classes=new_categories_names)

new_categories_ids

DatasetCatalog.clear()
MetadataCatalog.clear()

from detectron2.data.build import get_detection_dataset_dicts
dataset_dicts_train = get_detection_dataset_dicts(['train', 'test_val'])

from detectron2.data.datasets import builtin_meta
_dataset_metadata_train = MetadataCatalog.get('train')
# _dataset_metadata_train.thing_colors = [cc['color'] for cc in builtin_meta.COCO_CATEGORIES]
# _dataset_metadata_test = MetadataCatalog.get('test')
# _dataset_metadata_test.thing_colors = [cc['color'] for cc in builtin_meta.COCO_CATEGORIES]
# _dataset_metadata_val = MetadataCatalog.get('val')
# _dataset_metadata_val.thing_colors = [cc['color'] for cc in builtin_meta.COCO_CATEGORIES]
_dataset_metadata_train

with open("/content/my_metadata.json", 'w+') as f:
    f.write(json.dumps(_dataset_metadata_train.as_dict()))

with open("/content/my_metadata.json", 'r') as file:
  meta = json.load(file)

new_categories_names

NUM_CLASSES = len(_dataset_metadata_train.thing_classes)
NUM_CLASSES

!pip install opencv-contrib-python

from google.colab.patches import cv2_imshow
import cv2
from detectron2.utils.visualizer import Visualizer
import random

for d in random.sample(dataset_dicts_train, 3):
  img = cv2.imread(d["file_name"])
  visualizer = Visualizer(img[:,:,::-1], metadata = _dataset_metadata_train, scale = 0.1)
  out = visualizer.draw_dataset_dict(d)
  cv2_imshow( out.get_image()[:, :, ::-1] )

!nvidia-smi

"""![image.png](data:image/png;base64,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)"""

import os
from detectron2 import model_zoo
from detectron2.engine import DefaultTrainer, DefaultPredictor
from detectron2.config import get_cfg
from detectron2.utils.visualizer import ColorMode, Visualizer

cfg = get_cfg()

cfg.merge_from_file(model_zoo.get_config_file("COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"))

cfg.DATASETS.TRAIN = ("train",)
cfg.DATASETS.TEST = ("test_val",)
cfg.DATALOADER.NUM_WORKERS = 2
cfg.DATALOADER.SAMPLE_TRAIN = 'RepeatFactorTrainingSampler'
cfg.DATALOADER.REPEAT_THRESHOLD = 0.3

cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url("COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml")

cfg.SOLVER.IMS_PER_BATCH = 2
cfg.SOLVER.BASE_LR = 0.0025
cfg.SOLVER.MAX_ITER = 3000


cfg.SOLVER.CHECKPOINT_PERIOD = 1000


# minimum image size for the train set
cfg.INPUT.MIN_SIZE_TRAIN = (800,)
# maximum image size for the train set
cfg.INPUT.MAX_SIZE_TRAIN = 1333
# minimum image size for the test set
cfg.INPUT.MIN_SIZE_TEST = 800
# maximum image size for the test set
cfg.INPUT.MAX_SIZE_TEST = 1333

cfg.INPUT.RANDOM_FLIP = "horizontal"

cfg.MODEL.ROI_HEADS.BATCH_SIZE_PER_IMAGE = 512 #128
cfg.MODEL.ROI_HEADS.NUM_CLASSES = NUM_CLASSES

os.makedirs(cfg.OUTPUT_DIR, exist_ok=True)

trainer = DefaultTrainer(cfg)
trainer.resume_or_load(resume=False)

# Commented out IPython magic to ensure Python compatibility.
# %reload_ext tensorboard
# %load_ext tensorboard
# %tensorboard --logdir output

trainer.train()

from detectron2.evaluation import COCOEvaluator, inference_on_dataset
from detectron2.data import build_detection_test_loader

# Create predictor
cfg.MODEL.WEIGHTS = os.path.join("/content/output/model_final.pth")
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5
predictor = DefaultPredictor(cfg)

#Call the COCO Evaluator function and pass the Validation Dataset
evaluator = COCOEvaluator("test_val", cfg, False, output_dir="/content/output/")
val_loader = build_detection_test_loader(cfg, "test_val")

#Use the created predicted model in the previous step
inference_on_dataset(predictor.model, val_loader, evaluator)

register_coco_instances('inf',{},'/content/SplittedData/inf.json', '/content/TACO/data')
dataset_dicts_inf = get_detection_dataset_dicts(['inf'])

outputs["instances"]

from detectron2.data.catalog import Metadata
import cv2, cv2_imshow
my_metadata = Metadata()
my_metadata.set(thing_classes=['metals_and_plastics', 'other', 'non-recyclable', 'glass', 'paper', 'bio', 'unknown'])

for d in random.sample(dataset_dicts_train, 3):
    img = cv2.imread(d["file_name"])
    outputs = predictor(img)
    v = Visualizer(img[:, :, ::-1],
                   metadata=my_metadata, #_dataset_metadata_train,
                   scale=0.15,
                   instance_mode=ColorMode.IMAGE_BW # removes the colors of unsegmented pixels
    )
    v = v.draw_instance_predictions(outputs["instances"].to("cpu"))
    plt.figure(figsize = (14, 10))
    cv2_imshow(v.get_image()[:, :, ::-1] )
    #plt.imshow(cv2.cvtColor(v.get_image()[:, :, ::-1], cv2.COLOR_BGR2RGB))
    plt.show()

    # show original images from the dataset
    visualizer = Visualizer(img[:,:,::-1], metadata = my_metadata, scale = 0.15)
    out = visualizer.draw_dataset_dict(d)
    cv2_imshow( out.get_image()[:, :, ::-1] )

def load_json_arr(json_path):
    lines = []
    with open(json_path, 'r') as f:
        for line in f:
            lines.append(json.loads(line))
    return lines

experiment_metrics = load_json_arr('/content/output/' + '/metrics.json')

plt.plot(
    [x['iteration'] for x in experiment_metrics],
    [x['total_loss'] for x in experiment_metrics])
plt.legend(['total_loss'], loc='upper left')
plt.show()
plt.plot(
    [x['iteration'] for x in experiment_metrics if 'mask_rcnn/accuracy' in x],
    [x['mask_rcnn/accuracy'] for x in experiment_metrics if 'mask_rcnn/accuracy' in x])
plt.legend(['mask_rcnn/accuracy'], loc='upper left')
plt.show()

from google.colab import files
# !zip -r /content/splits.zip /content/SplittedData

files.download("/content/output/metrics.json")
!zip -r /content/model.zip /content/model_final.pth in google street

files.download("/content/SplittedData")

! du -sh '/content/output/model_final.pth'

# download, decompress the data
!wget https://github.com/Tony607/detectron2_instance_segmentation_demo/releases/download/V0.1/data.zip
!unzip data.zip > /dev/null

!rm -rf '/content/SplittedData'